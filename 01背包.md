问题定义
01背包问题是经典的动态规划问题：

有一个容量为 
𝑊
 的背包。

有 
𝑛
 个物品，每个物品有 重量 
𝑤
𝑖
 和 价值 
𝑣
𝑖
。

每个物品只能 选或不选（01表示只能取一次）。

目标：在不超过背包容量的前提下，最大化总价值。

 
数学公式

设 
𝑑
𝑝
[
𝑖
]
[
𝑗
]
 表示前 
𝑖
 个物品在容量为 
𝑗
 时的最大价值：
𝑑
𝑝
[
𝑖
]
[
𝑗
]

=
max
⁡
(
𝑑
𝑝
[
𝑖
−
1
]
[
𝑗
]
,
  
𝑑
𝑝
[
𝑖
−
1
]
[
𝑗
−
𝑤
𝑖
]
+
𝑣
𝑖
)
如果不选第 
𝑖
 个物品 → 
𝑑
𝑝
[
𝑖
−
1
]
[
𝑗
]

如果选第 
𝑖
 个物品 → 
𝑑
𝑝
[
𝑖
−
1
]
[
𝑗
−
𝑤
𝑖
]
+
𝑣
𝑖

前提：
𝑗
≥
𝑤
𝑖

最终答案：
𝑑
𝑝
[
𝑛
]
[
𝑊
]

优化思路
二维 DP：时间复杂度 
𝑂
(
𝑛
𝑊
)
，空间复杂度 
𝑂
(
𝑛
𝑊
)
。

一维 DP：只用一维数组，从后往前更新，空间复杂度降为 
𝑂
(
𝑊
)
。

公式变为：

𝑑
𝑝
[
𝑗
]

=
max
⁡
(
𝑑
𝑝
[
𝑗
]
,
  
𝑑
𝑝
[
𝑗
−
𝑤
𝑖
]
+
𝑣
𝑖
)
更新时必须 逆序遍历 j，避免重复使用同一物品。

 Python代码
 
    def knapsack_01(weights, values, W):
      n = len(weights)
      dp = [0] * (W + 1)
    
    for i in range(n):
        for j in range(W, weights[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])
    
    return dp[W]

    # 示例
    weights = [2, 3, 4, 5]
    values = [3, 4, 5, 6]
    W = 8
    print(knapsack_01(weights, values, W))  # 输出 10
